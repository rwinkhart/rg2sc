#!/bin/python3
#
# Add iTunes SoundCheck meta-data from Replay Gain meta-data.
#
# Originally Adapted from rg2c.py by:
# Copyright © 2010 Rogério Theodoro de Brito
# And further adapted from rgToSc by stu247 (https://github.com/stu247)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation (or at your option, any
# latter version)

import os
import argparse
from mutagen.id3 import ID3, COMM
import mutagen

global args


def strip_txxx_apic(_audio):
    for _tag in _audio.pprint().split('\n'):
        if _tag.startswith('TXXX'):
            _txxx_tag = _tag.replace('=', ':', 1).split('=', 1)[0]
            _audio.pop(_txxx_tag)
        if _tag.startswith('APIC'):
            _audio.delall('APIC')


def gain_to_watts(gain):
    return pow(10, -gain*.1)


def to_hexstring(x):
    # leading space required; blame Apple
    return " %08X" % int(x)


def write_soundcheck(file):
    try:
        audio = ID3(file)
    except mutagen.id3.error:
        print('Not an ID3 file (%s)' % file)
        return

    if args.strip and not args.force:
        strip_txxx_apic(audio)
        audio.update_to_v23()
        audio.save(v2_version=3)
        print('TXXX and APIC tags successfully stripped.')
        return

    # The format of the key is different between GNU/Linux and Windows!
    if not args.force and (audio.get(u"COMM:iTunNORM:'eng'") or
                           audio.get(u"COMM:iTunNORM:eng")):
        # the file already has iTunNORM, by default, do not touch the file
        return

    # get the values

    print(file)
    rggain = audio.get(u"TXXX:replaygain_track_gain")
    if rggain is None:
        rggain = audio.get(u"TXXX:REPLAYGAIN_TRACK_GAIN")
    if rggain is None:
        print('Error: could not find ReplayGain gain')
        return
    else:
        try:
            gain = float(str(rggain)[:-3])
        except:
            print('Error: ReplayGain gain not valid (%s)' % rggain)
            return

    rgpeak = audio.get(u"TXXX:replaygain_track_peak")
    if rgpeak is None:
        rgpeak = audio.get(u"TXXX:REPLAYGAIN_TRACK_PEAK")
    if rgpeak is None:
        print('Error: could not find ReplayGain peak')
        return
    else:
        try:
            peak = float(str(rgpeak))
        except:
            print('Error: ReplayGain peak not valid (%s)' % rgpeak)
            return

    # write the values

    values = [
        to_hexstring(1000 * gain_to_watts(gain)),
        to_hexstring(1000 * gain_to_watts(gain)),
        to_hexstring(2500 * gain_to_watts(gain)),
        to_hexstring(2500 * gain_to_watts(gain)),
        " 00000000",
        " 00000000",
        to_hexstring(peak * (32*1024 - 1)),
        to_hexstring(peak * (32*1024 - 1)),
        " 00000000",
        " 00000000",
        ]

    audio.add(COMM(desc="iTunNORM", lang="eng", text="".join(values), encoding=3))
    if args.strip:
        strip_txxx_apic(audio)
    audio.update_to_v23()
    audio.save(v2_version=3)
    if args.strip:
        print('TXXX and APIC tags successfully stripped.')
    print('ReplayGain values successfully converted.')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='''
Add iTunes SoundCheck meta-data from Replay Gain meta-data.
Replay Gain data is read from ID3v2 TXXX frames and SoundCheck data is stored
in iTunNORM COMM frame. By default, the script does not update SoundCheck data
if it already exists in the file.
''')
    parser.add_argument('music_file_or_dir', nargs='+',
                        help='Music file or directory tree containing music files.')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Update SoundCheck meta-data even if it already exists.')
    parser.add_argument('-s', '--strip', action='store_true',
                        help='Strip all TXXX tags from the output files (will not write SoundCheck tags without -f).')
    args = parser.parse_args()

    # process the list of directories and files
    for arg in args.music_file_or_dir:
        if os.path.isdir(arg):
            for dirPath, dirNames, filenames in os.walk(arg):
                for filename in filenames:
                    write_soundcheck(os.path.join(dirPath, filename))
        elif os.path.isfile(arg):
            write_soundcheck(arg)
        else:
            print("Error: %s is not a file or directory." % arg)
